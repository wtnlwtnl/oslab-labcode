# 操作系统实验四：内核线程管理

## 实验概述

本实验的目的是理解内核线程创建/执行的管理过程。需要完成内核线程的创建所需的资源分配，内核线程的切换，以及内核线程的基本调度过程的实现。通过本实验，我们将深入理解进程控制块的管理、进程创建、进程调度等核心操作系统概念。

## 练习1：分配并初始化一个进程控制块

### 设计实现过程

`alloc_proc`函数负责分配并返回一个新的`struct proc_struct`结构，用于存储新建立的内核线程的管理信息。该函数需要对进程控制块的各个字段进行适当的初始化。

### 代码实现

```c
static struct proc_struct *
alloc_proc(void)
{
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL)
    {
        // LAB4:EXERCISE1 2310984
        /*
         * below fields in proc_struct need to be initialized
         *       enum proc_state state;                      // Process state
         *       int pid;                                    // Process ID
         *       int runs;                                   // the running times of Proces
         *       uintptr_t kstack;                           // Process kernel stack
         *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?
         *       struct proc_struct *parent;                 // the parent process
         *       struct mm_struct *mm;                       // Process's memory management field
         *       struct context context;                     // Switch here to run process
         *       struct trapframe *tf;                       // Trap frame for current interrupt
         *       uintptr_t pgdir;                            // the base addr of Page Directroy Table(PDT)
         *       uint32_t flags;                             // Process flag
         *       char name[PROC_NAME_LEN + 1];               // Process name
         */
        
        // 初始化进程控制块的各个字段
        proc->state = PROC_UNINIT;          // 进程状态：未初始化
        proc->pid = -1;                     // 进程ID：-1表示尚未分配
        proc->runs = 0;                     // 运行次数：初始为0
        proc->kstack = 0;                   // 内核栈：初始为0，后续分配
        proc->need_resched = 0;             // 调度标志：不需要调度
        proc->parent = NULL;                // 父进程：初始为空
        proc->mm = NULL;                    // 内存管理：初始为空
        memset(&(proc->context), 0, sizeof(struct context)); // 上下文：清零
        proc->tf = NULL;                    // 陷阱帧：初始为空
        proc->pgdir = boot_pgdir_pa;        // 页目录：使用内核页目录
        proc->flags = 0;                    // 标志位：清零
        memset(proc->name, 0, PROC_NAME_LEN); // 进程名：清零
    }
    return proc;
}
```

### 代码分析

1. **内存分配**：使用`kmalloc`分配进程控制块内存
2. **状态初始化**：将进程状态设置为`PROC_UNINIT`（未初始化）
3. **资源初始化**：将各种资源指针设为NULL或0，表示尚未分配
4. **页目录设置**：设置为内核页目录，确保内核线程能正确访问内核空间
5. **上下文清零**：使用`memset`将上下文结构体清零

这种初始化策略确保了新创建的进程控制块处于一个清洁、可预测的状态，为后续的资源分配和初始化奠定了基础。

### 问题回答

**请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？**

**struct context context的含义和作用：**
- **含义**：进程上下文，包含进程切换时需要保存的关键寄存器（ra、sp、s0-s11等）
- **作用**：在进程调度切换时，`switch_to`函数使用这个结构体保存当前进程的寄存器状态，并恢复目标进程的寄存器状态
- **使用场景**：进程主动让出CPU或被调度器强制切换时
- **特点**：轻量级的上下文切换，只保存callee-saved寄存器

**struct trapframe *tf的含义和作用：**
- **含义**：陷阱帧指针，指向保存在内核栈上的完整寄存器现场
- **作用**：当进程从用户态陷入内核态时（如系统调用、异常、中断），保存完整的寄存器状态；当从内核态返回用户态时，从这个结构体恢复寄存器状态
- **使用场景**：系统调用、异常处理、中断处理的进入和退出
- **特点**：完整的寄存器现场保存，包含所有寄存器

**两者的区别**：
- `context`用于进程间切换（同特权级切换）
- `trapframe`用于特权级切换（用户态↔内核态）
- `context`是轻量级切换，`trapframe`是完整状态保存

## 练习2：为新创建的内核线程分配资源

### 设计实现过程

`do_fork`函数负责创建新的内核线程并为其分配各种资源。该函数实现了进程的"fork"操作，创建当前内核线程的一个副本。

### 代码实现

```c
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    // LAB4:EXERCISE2 2310984
    /*
     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
     * MACROs or Functions:
     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)
     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack
     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags
     *                 if clone_flags & CLONE_VM, then "share" ; else "duplicate"
     *   copy_thread:  setup the trapframe on the  process's kernel stack top and
     *                 setup the kernel entry point and stack of process
     *   hash_proc:    add proc into proc hash_list
     *   get_pid:      alloc a unique pid for process
     *   wakeup_proc:  set proc->state = PROC_RUNNABLE
     * VARIABLES:
     *   proc_list:    the process set's list
     *   nr_process:   the number of process set
     */

    //    1. call alloc_proc to allocate a proc_struct
    //    2. call setup_kstack to allocate a kernel stack for child process
    //    3. call copy_mm to dup OR share mm according clone_flag
    //    4. call copy_thread to setup tf & context in proc_struct
    //    5. insert proc_struct into hash_list && proc_list
    //    6. call wakeup_proc to make the new child process RUNNABLE
    //    7. set ret vaule using child proc's pid

    // 1. 调用 alloc_proc 分配一个进程控制块
    if ((proc = alloc_proc()) == NULL) {
        goto fork_out;
    }

    // 设置子进程的父进程为当前进程
    proc->parent = current;

    // 2. 调用 setup_kstack 为子进程分配内核栈
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }

    // 3. 调用 copy_mm 复制或共享内存管理信息
    if (copy_mm(clone_flags, proc) != 0) {
        goto bad_fork_cleanup_kstack;
    }

    // 4. 调用 copy_thread 设置陷阱帧和上下文
    copy_thread(proc, stack, tf);

    // 5. 将进程添加到哈希表和进程列表
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        proc->pid = get_pid();
        hash_proc(proc);
        list_add(&proc_list, &(proc->list_link));
        nr_process++;
    }
    local_intr_restore(intr_flag);

    // 6. 调用 wakeup_proc 使新进程变为可运行状态
    wakeup_proc(proc);

    // 7. 设置返回值为子进程的pid
    ret = proc->pid;

fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```

### 代码分析

1. **进程控制块分配**：调用`alloc_proc()`创建并初始化新的进程控制块
2. **父子关系建立**：设置新进程的parent指针指向当前进程
3. **内核栈分配**：通过`setup_kstack()`为新进程分配独立的内核栈
4. **内存管理复制**：调用`copy_mm()`处理内存管理信息（内核线程不需要）
5. **上下文设置**：通过`copy_thread()`设置陷阱帧和进程切换上下文
6. **进程管理**：在关中断状态下分配PID并将进程加入管理结构
7. **进程激活**：调用`wakeup_proc()`将新进程设为可运行状态
8. **错误处理**：完善的错误清理机制，确保资源不会泄露

### 问题回答

**请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。**

**答案**：是的，ucore能够给每个新fork的线程分配唯一的ID。

**分析和理由**：

1. **唯一性保证机制**：
   - ucore通过`get_pid()`函数实现唯一ID分配
   - 使用静态变量`last_pid`和`next_safe`维护分配状态
   - 采用递增策略并进行冲突检测

2. **分配算法**：
   ```c
   static int get_pid(void)
   {
       // 1. 简单递增策略
       if (++last_pid >= MAX_PID) {
           last_pid = 1;  // 超过最大值时重置为1
       }
       
       // 2. 冲突检测机制
       if (last_pid >= next_safe) {
           // 遍历所有进程检查PID冲突
           // 如果发现冲突，继续递增并重新检查
       }
       
       return last_pid;
   }
   ```

3. **优化策略**：
   - 维护`next_safe`值，减少不必要的遍历
   - 大多数情况下通过简单递增即可快速分配
   - 只有在接近冲突区域时才进行复杂检查

4. **范围限制**：
   - PID范围：1到`MAX_PID-1`
   - PID=0预留给idle进程
   - 确保了足够的PID空间

5. **原子性保证**：
   - PID分配过程在关中断状态下进行
   - 避免并发访问导致的竞争条件

这种设计既保证了PID的唯一性，又尽可能减少了分配的时间复杂度，是一种平衡效率和正确性的优秀设计。

## 练习3：编写proc_run函数

### 设计实现过程

`proc_run`函数用于将指定的进程切换到CPU上运行，实现进程之间的切换。

### 代码实现

```c
void proc_run(struct proc_struct *proc)
{
    if (proc != current)
    {
        // LAB4:EXERCISE3 2310984
        /*
         * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
         * MACROs or Functions:
         *   local_intr_save():        Disable interrupts
         *   local_intr_restore():     Enable Interrupts
         *   lsatp():                   Modify the value of satp register
         *   switch_to():              Context switching between two processes
         */

        // 禁用中断，确保进程切换过程的原子性
        bool intr_flag;
        struct proc_struct *prev = current;
        local_intr_save(intr_flag);
        {
            // 切换当前进程为要运行的进程
            current = proc;
            // 切换页表，以便使用新进程的地址空间
            lsatp(proc->pgdir);
            // 实现上下文切换，保存当前进程状态并恢复目标进程状态
            switch_to(&(prev->context), &(proc->context));
        }
        // 恢复中断
        local_intr_restore(intr_flag);
    }
}
```

### 代码分析

1. **进程比较**：首先检查要切换的进程是否与当前进程相同
2. **中断禁用**：使用`local_intr_save()`禁用中断，确保切换过程的原子性
3. **进程切换**：更新全局变量`current`指向新进程
4. **页表切换**：调用`lsatp()`切换页表，使用新进程的地址空间
5. **上下文切换**：调用`switch_to()`实现寄存器状态的保存和恢复
6. **中断恢复**：使用`local_intr_restore()`重新启用中断

这种设计保证了进程切换的原子性和正确性，避免了竞争条件。

### 问题回答

**在本实验的执行过程中，创建且运行了几个内核线程？**

**答案**：在本实验中创建并运行了**2个内核线程**。

**详细分析**：

1. **idle进程（idleproc）**：
   - **PID**：0
   - **创建方式**：在`proc_init()`中直接通过`alloc_proc()`创建
   - **状态**：PROC_RUNNABLE
   - **功能**：系统空闲进程，当没有其他可运行进程时运行
   - **执行函数**：`cpu_idle()` - 无限循环检查是否需要调度

2. **init进程（initproc）**：
   - **PID**：1
   - **创建方式**：在`proc_init()`中通过`kernel_thread(init_main, "Hello world!!", 0)`创建
   - **状态**：PROC_RUNNABLE（创建后通过`wakeup_proc`设置）
   - **功能**：第二个内核线程，用于后续创建用户进程
   - **执行函数**：`init_main()` - 打印信息后退出

**执行流程**：
1. 系统启动：`kern_init()` → `proc_init()`
2. idle进程创建：作为第0号进程
3. init进程创建：通过`kernel_thread()`调用`do_fork()`创建
4. 调度开始：`cpu_idle()`开始调度循环
5. 进程切换：调度器在idle和init进程之间切换执行

## 重要知识点分析

### 实验中的重要知识点

1. **进程控制块（PCB）**：
   - **实验含义**：`struct proc_struct`结构体，包含进程的所有管理信息
   - **OS原理对应**：进程控制块是操作系统管理进程的核心数据结构
   - **关系**：实验中的实现是对理论概念的具体体现

2. **进程状态转换**：
   - **实验含义**：PROC_UNINIT → PROC_RUNNABLE → PROC_SLEEPING → PROC_ZOMBIE
   - **OS原理对应**：五状态模型（新建、就绪、运行、阻塞、终止）
   - **差异**：实验简化了状态模型，主要关注内核线程

3. **上下文切换**：
   - **实验含义**：通过`switch_to()`函数实现寄存器状态的保存和恢复
   - **OS原理对应**：进程调度中的上下文切换机制
   - **关系**：实验提供了上下文切换的底层实现

4. **进程创建（fork机制）**：
   - **实验含义**：`do_fork()`函数实现进程复制
   - **OS原理对应**：fork系统调用的实现机制
   - **特点**：实验中专注于内核线程的创建

5. **进程调度**：
   - **实验含义**：简单的轮转调度算法
   - **OS原理对应**：多种调度算法（FCFS、SJF、RR等）
   - **差异**：实验实现较为简单，主要用于验证基本机制

### OS原理中重要但实验未涉及的知识点

1. **进程间通信（IPC）**：
   - 管道、消息队列、共享内存、信号量等
   - 实验主要关注内核线程，未涉及复杂的IPC机制

2. **死锁处理**：
   - 死锁预防、避免、检测和恢复
   - 实验中的同步机制较为简单，未涉及死锁问题

3. **优先级调度**：
   - 多级反馈队列、优先级调度算法
   - 实验中使用简单的轮转调度

4. **进程同步与互斥**：
   - 临界区、信号量、监程等复杂同步机制
   - 实验主要通过中断控制实现简单的同步

5. **虚拟内存管理**：
   - 页面置换算法、工作集模型等
   - 实验中内核线程使用统一的内核地址空间

## 扩展练习分析

### Challenge 1：中断开关机制分析

**语句`local_intr_save(intr_flag);....local_intr_restore(intr_flag);`的实现原理**：

```c
#define local_intr_save(x) \
    do { x = __intr_save(); } while (0)
#define local_intr_restore(x) __intr_restore(x);

static inline bool __intr_save(void) {
    if (read_csr(sstatus) & SSTATUS_SIE) {
        intr_disable();
        return 1;
    }
    return 0;
}

static inline void __intr_restore(bool flag) {
    if (flag) {
        intr_enable();
    }
}
```

**实现机制**：
1. 保存当前中断状态到变量中
2. 禁用中断执行临界区代码
3. 根据保存的状态恢复中断设置
4. 确保了嵌套调用的正确性

### Challenge 2：分页模式工作原理

**get_pte()函数中相似代码段的分析**：

两段相似代码分别处理不同级别的页表查找，这种相似性源于：

1. **分页机制的层次性**：无论是SV32、SV39还是SV48，都采用多级页表结构
2. **统一的查找逻辑**：每一级页表的查找过程都是相似的
3. **递归性质**：页表查找本质上是一个递归过程

**关于函数设计的思考**：
- **优点**：简化了接口，一次调用完成查找和分配
- **缺点**：功能耦合，不够灵活
- **改进建议**：可以分离查找和分配功能，提高代码的可维护性和灵活性

## 实验运行结果分析

### 编译运行结果

使用`make qemu`命令编译并运行实验，得到以下关键输出：

```
OpenSBI v0.4 (Jul  2 2019 11:53:53)
Platform Name          : QEMU Virt Machine
...
(THU.CST) os is loading ...
memory management: default_pmm_manager
check_alloc_page() succeeded!
check_pgdir() succeeded!
check_boot_pgdir() succeeded!
kmalloc_init() succeeded!
check_vma_struct() succeeded!
check_vmm() succeeded.
alloc_proc() correct!
++ setup timer interrupts
this initproc, pid = 1, name = "init"
To U: "Hello world!!".
To U: "en.., Bye, Bye. :)"
kernel panic at kern/process/proc.c:408:
    process exit!!.
```

### 结果分析

1. **系统初始化成功**：
   - OpenSBI启动正常，平台识别正确
   - 内存管理各项检查全部通过
   - 物理内存管理器初始化成功

2. **进程管理实现正确**：
   - `alloc_proc() correct!` 证明练习1实现正确
   - 时钟中断设置成功
   - init进程（PID=1）创建并运行成功

3. **进程执行流程正确**：
   - init进程正常输出预期信息
   - 进程执行完毕后正确调用退出函数
   - 最终的`panic("process exit!!");`是预期结果，说明进程生命周期完整

4. **实验目标达成**：
   - 成功创建了2个内核线程（idle和init）
   - 进程调度和切换机制工作正常
   - 进程控制块管理功能完整

### 性能表现

- **编译无严重错误**：只有一个类型转换警告，不影响功能
- **运行稳定**：系统正常启动并执行完整的进程生命周期
- **功能完备**：所有练习要求的功能都得到正确实现

## 实验总结

本实验通过实现进程控制块的分配、进程创建和进程切换等核心功能，深入理解了操作系统进程管理的基本机制。实验涵盖了进程生命周期的关键环节，为后续实验奠定了坚实的基础。

**主要成就**：
1. 成功实现了进程控制块的正确初始化
2. 完整实现了进程创建的资源分配过程
3. 正确实现了进程切换和调度机制
4. 验证了内核线程的完整生命周期

**实验验证**：通过运行结果可以确认，所有核心功能都按预期工作，系统能够正常创建、调度和执行内核线程，达到了实验的全部目标。

通过编码实现，我们不仅理解了理论知识，更重要的是掌握了操作系统底层机制的具体实现方法，为深入理解操作系统原理打下了坚实的实践基础。