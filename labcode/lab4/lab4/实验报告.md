# 操作系统实验四：内核线程管理

## 实验概述

本实验的目的是理解内核线程创建/执行的管理过程。需要完成内核线程的创建所需的资源分配，内核线程的切换，以及内核线程的基本调度过程的实现。通过本实验，我们将深入理解进程控制块的管理、进程创建、进程调度等核心操作系统概念。

## 练习1：分配并初始化一个进程控制块

### 设计实现过程

`alloc_proc`函数负责分配并返回一个新的`struct proc_struct`结构，用于存储新建立的内核线程的管理信息。该函数需要对进程控制块的各个字段进行适当的初始化。

### 代码实现

```c
static struct proc_struct *
alloc_proc(void)
{
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL)
    {
        // LAB4:EXERCISE1 2310984
        /*
         * below fields in proc_struct need to be initialized
         *       enum proc_state state;                      // Process state
         *       int pid;                                    // Process ID
         *       int runs;                                   // the running times of Proces
         *       uintptr_t kstack;                           // Process kernel stack
         *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?
         *       struct proc_struct *parent;                 // the parent process
         *       struct mm_struct *mm;                       // Process's memory management field
         *       struct context context;                     // Switch here to run process
         *       struct trapframe *tf;                       // Trap frame for current interrupt
         *       uintptr_t pgdir;                            // the base addr of Page Directroy Table(PDT)
         *       uint32_t flags;                             // Process flag
         *       char name[PROC_NAME_LEN + 1];               // Process name
         */
        
        // 初始化进程控制块的各个字段
        proc->state = PROC_UNINIT;          // 进程状态：未初始化
        proc->pid = -1;                     // 进程ID：-1表示尚未分配
        proc->runs = 0;                     // 运行次数：初始为0
        proc->kstack = 0;                   // 内核栈：初始为0，后续分配
        proc->need_resched = 0;             // 调度标志：不需要调度
        proc->parent = NULL;                // 父进程：初始为空
        proc->mm = NULL;                    // 内存管理：初始为空
        memset(&(proc->context), 0, sizeof(struct context)); // 上下文：清零
        proc->tf = NULL;                    // 陷阱帧：初始为空
        proc->pgdir = boot_pgdir_pa;        // 页目录：使用内核页目录
        proc->flags = 0;                    // 标志位：清零
        memset(proc->name, 0, PROC_NAME_LEN); // 进程名：清零
    }
    return proc;
}
```

### 代码分析

在该实现中，`alloc_proc`首先使用`kmalloc`分配进程控制块所需的内存空间，确保后续字段初始化都有可靠的存储位置。随后函数把进程状态设为`PROC_UNINIT`并将`pid`、`runs`、`kstack`等字段初始化为默认值，使新建的控制块从一个可预测的起点出发。各种指针字段被赋值为`NULL`或零，意味着相关资源尚未分配；这一步结合将页目录设为`boot_pgdir_pa`的做法，让内核线程默认使用内核页表。最后，代码通过`memset`清空上下文结构体和进程名，保证切换所需的寄存器现场为零初始化。

这种初始化策略确保了新创建的进程控制块处于一个清洁、可预测的状态，为后续的资源分配和初始化奠定了基础。

### 问题回答

**请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？**

`proc_struct`中的`struct context context`用于描述进程上下文，它记录了在进程切换时必须保留的关键寄存器，例如`ra`、`sp`以及`s0`到`s11`等寄存器。调度器调用`switch_to`时会把当前进程的这些寄存器保存在该结构中，并在目标进程被唤起时恢复到CPU，因此它主要服务于进程主动让出或被调度器切换的场合，属于轻量级的寄存器保存。与之对应，`struct trapframe *tf`指向保存在内核栈上的完整寄存器现场，当进程因为系统调用、异常或中断从用户态进入内核态时，所有寄存器都会按约定压入栈中形成陷阱帧；返回用户态时再由该结构恢复。`context`仅关注内核态进程切换所需的callee-saved寄存器，而`trapframe`则承担特权级切换所需的完整寄存器保存，两者在保存范围和触发场景上各有侧重。

## 练习2：为新创建的内核线程分配资源

### 设计实现过程

`do_fork`函数负责创建新的内核线程并为其分配各种资源。该函数实现了进程的"fork"操作，创建当前内核线程的一个副本。

### 代码实现

```c
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    // LAB4:EXERCISE2 2310984
    /*
     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
     * MACROs or Functions:
     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)
     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack
     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags
     *                 if clone_flags & CLONE_VM, then "share" ; else "duplicate"
     *   copy_thread:  setup the trapframe on the  process's kernel stack top and
     *                 setup the kernel entry point and stack of process
     *   hash_proc:    add proc into proc hash_list
     *   get_pid:      alloc a unique pid for process
     *   wakeup_proc:  set proc->state = PROC_RUNNABLE
     * VARIABLES:
     *   proc_list:    the process set's list
     *   nr_process:   the number of process set
     */

    //    1. call alloc_proc to allocate a proc_struct
    //    2. call setup_kstack to allocate a kernel stack for child process
    //    3. call copy_mm to dup OR share mm according clone_flag
    //    4. call copy_thread to setup tf & context in proc_struct
    //    5. insert proc_struct into hash_list && proc_list
    //    6. call wakeup_proc to make the new child process RUNNABLE
    //    7. set ret vaule using child proc's pid

    // 1. 调用 alloc_proc 分配一个进程控制块
    if ((proc = alloc_proc()) == NULL) {
        goto fork_out;
    }

    // 设置子进程的父进程为当前进程
    proc->parent = current;

    // 2. 调用 setup_kstack 为子进程分配内核栈
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }

    // 3. 调用 copy_mm 复制或共享内存管理信息
    if (copy_mm(clone_flags, proc) != 0) {
        goto bad_fork_cleanup_kstack;
    }

    // 4. 调用 copy_thread 设置陷阱帧和上下文
    copy_thread(proc, stack, tf);

    // 5. 将进程添加到哈希表和进程列表
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        proc->pid = get_pid();
        hash_proc(proc);
        list_add(&proc_list, &(proc->list_link));
        nr_process++;
    }
    local_intr_restore(intr_flag);

    // 6. 调用 wakeup_proc 使新进程变为可运行状态
    wakeup_proc(proc);

    // 7. 设置返回值为子进程的pid
    ret = proc->pid;

fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```

### 代码分析

`do_fork`的执行路径首先调用`alloc_proc()`创建并初始化新的进程控制块，并在第一时间把父子关系建立为当前正在运行的进程。紧接着，函数使用`setup_kstack()`为子进程分配独立的内核栈，与此同时会在失败时按照预定顺序进行回滚。之后通过`copy_mm()`决定是复制还是共享内存管理信息，并调用`copy_thread()`完成陷阱帧与上下文的布置。所有核心资源准备完毕后，代码在关中断的保护下为子进程分配唯一的PID，将其挂入进程哈希表和全局进程链表并维护`nr_process`计数，随后调用`wakeup_proc()`把进程状态切换为就绪。若任一步骤失败，对应的清理逻辑会释放内核栈和进程控制块，避免资源泄露。

### 问题回答

**请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。**

**答案**：是的，ucore能够给每个新fork的线程分配唯一的ID。

ucore通过`get_pid()`函数完成PID的分配，该函数使用静态变量`last_pid`与`next_safe`维护进程号的使用情况，并采用递增策略结合冲突检测来确保唯一性。其大致流程如下所示：

```c
static int get_pid(void)
{
    if (++last_pid >= MAX_PID) {
        last_pid = 1;
    }
    if (last_pid >= next_safe) {
        // 遍历所有进程检查PID冲突
    }
    return last_pid;
}
```

每当`last_pid`逼近`next_safe`时，内核会遍历当前的进程集合，跳过所有已被占用的PID，从而在允许范围内寻找下一段安全区间。由于PID分配是在关中断的状态下执行的，这一过程天然具有原子性，不会受到并发访问的影响。同时，PID取值被限定在`1`到`MAX_PID-1`之间，而`0`号PID保留给`idleproc`，既保证了足够的编号空间，也避免了与核心线程发生冲突。综合来看，这套机制在保证唯一性的同时兼顾了效率和可扩展性。

## 练习3：编写proc_run函数

### 设计实现过程

`proc_run`函数用于将指定的进程切换到CPU上运行，实现进程之间的切换。

### 代码实现

```c
void proc_run(struct proc_struct *proc)
{
    if (proc != current)
    {
        // LAB4:EXERCISE3 2310984
        /*
         * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
         * MACROs or Functions:
         *   local_intr_save():        Disable interrupts
         *   local_intr_restore():     Enable Interrupts
         *   lsatp():                   Modify the value of satp register
         *   switch_to():              Context switching between two processes
         */

        // 禁用中断，确保进程切换过程的原子性
        bool intr_flag;
        struct proc_struct *prev = current;
        local_intr_save(intr_flag);
        {
            // 切换当前进程为要运行的进程
            current = proc;
            // 切换页表，以便使用新进程的地址空间
            lsatp(proc->pgdir);
            // 实现上下文切换，保存当前进程状态并恢复目标进程状态
            switch_to(&(prev->context), &(proc->context));
        }
        // 恢复中断
        local_intr_restore(intr_flag);
    }
}
```

### 代码分析

函数体首先比较目标进程与当前进程是否相同，如果并非同一个实体才进入切换流程。为了保证切换的原子性，代码通过`local_intr_save()`关闭中断并保存原有的中断状态，然后更新全局变量`current`使之指向新的目标进程。紧接着调用`lsatp()`更新页表寄存器，让处理器加载目标进程的地址空间，再由`switch_to()`完成上下文切换，保存旧进程的寄存器状态并恢复新进程的寄存器现场。最后使用`local_intr_restore()`恢复之前的中断状态，从而以一种受控的方式完成切换。

### 问题回答

**在本实验的执行过程中，创建且运行了几个内核线程？**

**答案**：在本实验中创建并运行了**2个内核线程**。

**详细分析**：

实验过程中，首先由`proc_init()`直接调用`alloc_proc()`创建PID为0的idle进程，它被初始化为`PROC_RUNNABLE`并运行`cpu_idle()`函数，在系统没有其他可运行线程时保持占用处理器。随后，同样在`proc_init()`中通过`kernel_thread(init_main, "Hello world!!", 0)`创建PID为1的init进程，该线程在被`wakeup_proc()`唤醒后处于可运行状态，并执行`init_main()`输出测试信息后退出。整体流程从`kern_init()`进入`proc_init()`开始，先完成idle进程的设置，再通过`do_fork()`衍生出init进程，之后调度器在`cpu_idle()`的调度循环中在两个线程之间切换，实现了实验所需的线程运行轨迹。

## 重要知识点分析

### 实验中的重要知识点

本次实验最核心的知识点包括进程控制块、进程状态、上下文切换、进程创建以及调度策略。`struct proc_struct`这一数据结构完整承载了内核线程的管理信息，其实现与理论课上介绍的PCB概念一一对应。进程状态虽然只在`PROC_UNINIT`、`PROC_RUNNABLE`、`PROC_SLEEPING`与`PROC_ZOMBIE`之间转换，却形象地映射了经典的五状态模型，只是将关注点限定在内核线程。利用`switch_to()`保存与恢复寄存器现场的过程，则将课本中的上下文切换机制落到了代码层面。`do_fork()`完成了线程复制所需的资源准备，是fork思想在内核线程场景下的具体化；而简单的轮转调度让我们得以观察最基本的调度流程与决策逻辑。

### OS原理中重要但实验未涉及的知识点

相较之下，若对标完整的操作系统课程，本实验并未覆盖诸如进程间通信、死锁处理、优先级调度、复杂的同步互斥机制以及深入的虚拟内存管理等主题。内核线程之间尚未引入管道、消息队列或共享内存一类的IPC工具；调度策略也暂未引入优先级和多级反馈队列，因而无法探讨饥饿或响应时间问题。同步方面主要依赖中断屏蔽，尚未展示信号量或监程带来的建模优势，同时内存管理仍围绕统一的内核地址空间，尚未触及页面置换算法或工作集模型。

## 扩展练习分析

### Challenge 1：中断开关机制分析

**语句`local_intr_save(intr_flag);....local_intr_restore(intr_flag);`的实现原理**：

```c
#define local_intr_save(x) \
    do { x = __intr_save(); } while (0)
#define local_intr_restore(x) __intr_restore(x);

static inline bool __intr_save(void) {
    if (read_csr(sstatus) & SSTATUS_SIE) {
        intr_disable();
        return 1;
    }
    return 0;
}

static inline void __intr_restore(bool flag) {
    if (flag) {
        intr_enable();
    }
}
```

这组宏在调用`local_intr_save`时首先检测当前的中断开启状态，将结果保存在传入的布尔变量中，然后立即关闭中断，为随后的临界区提供互斥保证；离开临界区时通过`local_intr_restore`读回保存的标志，若之前处于开中断状态则重新启用，从而在不破坏原始状态的前提下保障了嵌套调用的正确性。

### Challenge 2：分页模式工作原理

**get_pte()函数中相似代码段的分析**：

两段相似代码分别处理不同级别的页表查找，原因在于SV32、SV39以及SV48等分页模式都采用多级页表结构，每一级的索引与分配流程遵循统一的逻辑，同时也体现了递归查找的本质。将查找与分配统一在同一个函数内可以显著简化接口，使调用者在一次操作中即可获得所需的页表项，但这种耦合也降低了灵活性，若希望在某些场景下单纯查询而不分配便显得不够友好。更精细的设计可以将查找和分配拆分为两个互补的接口，以提升可维护性。

## 实验运行结果分析

### 编译运行结果

使用`make qemu`命令编译并运行实验，得到以下关键输出：

```
OpenSBI v0.4 (Jul  2 2019 11:53:53)
Platform Name          : QEMU Virt Machine
...
(THU.CST) os is loading ...
memory management: default_pmm_manager
check_alloc_page() succeeded!
check_pgdir() succeeded!
check_boot_pgdir() succeeded!
kmalloc_init() succeeded!
check_vma_struct() succeeded!
check_vmm() succeeded.
alloc_proc() correct!
++ setup timer interrupts
this initproc, pid = 1, name = "init"
To U: "Hello world!!".
To U: "en.., Bye, Bye. :)"
kernel panic at kern/process/proc.c:408:
    process exit!!.
```

### 结果分析

从运行日志可以看到系统初始化顺利完成：OpenSBI正确识别平台，各项内存管理检查全部通过，物理内存管理器初始化成功，为后续实验奠定了稳定基础。紧接着，进程管理相关的输出表明`alloc_proc()`实现得到验证，时钟中断顺利建立，init进程在创建后成功运行。随着调度器的切换，init线程打印出预期的信息并调用退出流程，最终触发的`panic("process exit!!");`正是实验的收尾信号，说明线程生命周期按照设计执行完毕。综合这些迹象，可以确认实验所需的两个内核线程都被正确创建并调度，PCB管理与调度机制按预期工作。

### 性能表现

整体性能表现稳健，编译阶段除了一个无碍功能的类型转换警告外没有出现严重错误，运行过程中系统能够持续稳定地完成内核线程的创建、调度与退出，表明实验要求的功能均被正确实现。

## 实验总结

本实验通过实现进程控制块的分配、进程创建和进程切换等核心功能，深入理解了操作系统进程管理的基本机制。实验涵盖了进程生命周期的关键环节，为后续实验奠定了坚实的基础。

本次实验的主要收获体现在多个方面：我们成功实现了进程控制块的正确初始化，完整完成了进程创建所需的资源分配，并凭借`proc_run`等关键函数验证了内核线程切换和调度机制的正确性。随着idle与init线程的全生命周期演示，线程管理链条得到了系统性的验证。运行结果进一步印证了这些实现的有效性，内核能够稳定地创建、调度并结束线程，实验目标因此全部达成。

通过编码实现，我们不仅理解了理论知识，更重要的是掌握了操作系统底层机制的具体实现方法，为深入理解操作系统原理打下了坚实的实践基础。